""" Copyright chriskeraly
    Copyright (c) 2019 Lumerical Inc. """

import sys
import numpy as np
import scipy as sp
import scipy.constants
import lumapi

class ModeMatch(object):

    """ Figure of Merit class based on the overlap integral between the fields recorded by a DFT monitor and the selected mode. 
        The class adds a mode expansion monitor to the simulation and links it to the provided DFT monitor. The mode expansion 
        monitor is used to retrieve the overlap result once the provided simulation has run. The overlap integral is that of 
        equation (7) of `https://doi.org/10.1364/OE.21.021693`, which is equivalent to the overlap integral built into FDTD and
        described in `https://kb.lumerical.com/ref_sim_obj_using_mode_expansion_monitors.html`.

        Parameters
        ----------
        :param monitor_name: name of the DFT monitor that records the fields to be used in the mode overlap calculation.
        :param wavelengths:  wavelengths of interest for the mode overlap calculation.
        :param mode_number:  selected mode in the list generated by the mode expansion monitor.
        :param direction:    direction of propagation of the mode injected by the source.
    """

    def __init__(self, monitor_name, wavelengths, mode_number, direction):
        self.monitor_name = str(monitor_name)
        if not self.monitor_name:
            raise UserWarning('empty monitor name.')
        self.mode_expansion_monitor_name = monitor_name + '_mode_exp'
        self.adjoint_source_name = monitor_name + '_mode_src'

        self.wavelengths = np.array([wavelengths]).flatten()
        if np.any(self.wavelengths <= 0.0):
            raise UserWarning('wavelengths must be positive')

        self.mode_number = int(mode_number)
        if self.mode_number <= 0:
            raise UserWarning('mode number should be positive.')

        self.direction = str(direction)
        if self.direction != 'Forward' and self.direction != 'Backward':
            raise UserWarning('invalid propagation direction.')

    def initialize(self, sim):
        pass

    def add_to_sim(self, sim):
        ModeMatch.add_mode_expansion_monitor(sim, self.monitor_name, self.mode_expansion_monitor_name, self.wavelengths, self.mode_number)

    @staticmethod
    def add_mode_expansion_monitor(sim, monitor_name, mode_expansion_monitor_name, wavelengths, mode_number):
        # modify existing DFT monitor
        if sim.fdtd.getnamednumber(monitor_name) != 1:
            raise UserWarning('monitor could not be found or the specified name is not unique.')
        sim.fdtd.setnamed(monitor_name, 'override global monitor settings', True)
        sim.fdtd.setnamed(monitor_name, 'use source limits', False)
        sim.fdtd.setnamed(monitor_name, 'use linear wavelength spacing', True)
        sim.fdtd.setnamed(monitor_name, 'frequency points', len(wavelengths))
        sim.fdtd.setnamed(monitor_name, 'wavelength center', 0.5 * float(wavelengths.max() + wavelengths.min()))
        if len(wavelengths) > 1:
            sim.fdtd.setnamed(monitor_name, 'wavelength span', float(wavelengths.max() - wavelengths.min()))
        # append a mode expansion monitor to the existing DFT monitor
        if sim.fdtd.getnamednumber(mode_expansion_monitor_name) == 0:
            sim.fdtd.addmodeexpansion()
            sim.fdtd.set('name', mode_expansion_monitor_name)
            sim.fdtd.setexpansion(mode_expansion_monitor_name, monitor_name)
            sim.fdtd.setnamed(mode_expansion_monitor_name, 'mode selection', 'user select')
            sim.fdtd.setnamed(mode_expansion_monitor_name, 'auto update before analysis', True)
            # properties that must be synchronized
            props = ['monitor type']
            monitor_type = sim.fdtd.getnamed(monitor_name, 'monitor type')
            geo_props, normal = ModeMatch.cross_section_monitor_props(monitor_type)
            props.extend(geo_props)
            props.extend(['override global monitor settings', 'use source limits', 'use linear wavelength spacing', 'wavelength center', 'frequency points'])
            if len(wavelengths) > 1:
                props.append('wavelength span')
            # synchronize properties
            for prop_name in props:
                prop_val = sim.fdtd.getnamed(monitor_name, prop_name)
                sim.fdtd.setnamed(mode_expansion_monitor_name, prop_name, prop_val)
            # select mode
            sim.fdtd.select(mode_expansion_monitor_name)
            sim.fdtd.updatemodes(mode_number)
        else:
            raise UserWarning('there is already a expansion monitor with the same name.')

    @staticmethod
    def cross_section_monitor_props(monitor_type):
        geometric_props = ['x', 'y', 'z']
        normal = ''
        if monitor_type == '2D X-normal':
            geometric_props.extend(['y span','z span'])
            normal = 'x'
        elif monitor_type == '2D Y-normal':
            geometric_props.extend(['x span','z span'])
            normal = 'y'
        elif monitor_type == '2D Z-normal':
            geometric_props.extend(['x span','y span'])
            normal = 'z'
        elif monitor_type == 'Linear X':
            geometric_props.append('x span')
            normal = 'y'
        elif monitor_type == 'Linear Y':
            geometric_props.append('y span')
            normal = 'x'
        elif monitor_type == 'Linear Z':
            geometric_props.append('z span')
        else:
            raise UserWarning('monitor should be 2D or linear for a mode expansion to be meaningful.')
        return geometric_props, normal

    def get_fom(self, sim):
        trans_coeff = ModeMatch.get_transmission_coefficient(sim, self.direction, self.monitor_name, self.mode_expansion_monitor_name)
        source_power = ModeMatch.get_source_power(sim, self.wavelengths)
        fom_vs_wavelength = trans_coeff * trans_coeff.conj() / source_power
        self.phase_prefactors = trans_coeff / 8.0 / source_power
        return fom_vs_wavelength.flatten().real

    @staticmethod
    def get_transmission_coefficient(sim, direction, monitor_name, mode_exp_monitor_name):
        mode_exp_result_name = 'expansion for ' + mode_exp_monitor_name
        if not sim.fdtd.haveresult(mode_exp_monitor_name, mode_exp_result_name):
            raise UserWarning('unable to calcualte mode expansion.')
        mode_exp_data_set = sim.fdtd.getresult(mode_exp_monitor_name, mode_exp_result_name)
        fwd_trans_coeff = mode_exp_data_set['a'] * np.sqrt(mode_exp_data_set['N'].real)
        back_trans_coeff = mode_exp_data_set['b'] * np.sqrt(mode_exp_data_set['N'].real)
        if direction == 'Backward':
            fwd_trans_coeff, back_trans_coeff = back_trans_coeff, fwd_trans_coeff
        return fwd_trans_coeff

    @staticmethod
    def get_source_power(sim, wavelengths):
        frequency = sp.constants.speed_of_light / wavelengths
        return sim.fdtd.sourcepower(frequency)

    def add_adjoint_sources(self, sim):
        adjoint_injection_direction = 'Backward' if self.direction == 'Forward' else 'Forward'
        ModeMatch.add_mode_source(sim, 
                                  self.monitor_name,
                                  self.adjoint_source_name,
                                  self.wavelengths,
                                  adjoint_injection_direction,
                                  self.mode_number)

    @staticmethod
    def add_mode_source(sim, monitor_name, source_name, wavelengths, direction, mode_number):
        sim.fdtd.addmode()
        sim.fdtd.set('name', source_name)
        monitor_type = sim.fdtd.getnamed(monitor_name, 'monitor type')
        geo_props, normal = ModeMatch.cross_section_monitor_props(monitor_type)
        sim.fdtd.setnamed(source_name, 'injection axis', normal.lower() + '-axis')
        for prop_name in geo_props:
            prop_val = sim.fdtd.getnamed(monitor_name, prop_name)
            sim.fdtd.setnamed(source_name, prop_name, prop_val)
        sim.fdtd.setnamed(source_name, 'override global source settings', True)
        sim.fdtd.setnamed(source_name, 'set wavelength', True)
        sim.fdtd.setnamed(source_name, 'center wavelength', 0.5 * float(wavelengths.max() + wavelengths.min()))
        sim.fdtd.setnamed(source_name, 'wavelength span', float(wavelengths.max() - wavelengths.min()))
        sim.fdtd.setnamed(source_name, 'direction', direction)
        sim.fdtd.setnamed(source_name, 'multifrequency mode calculation', False)
        #sim.fdtd.setnamed(source_name, 'frequency points', len(wavelengths))
        sim.fdtd.setnamed(source_name, 'mode selection', 'user select')
        sim.fdtd.select(source_name)
        sim.fdtd.updatesourcemode(mode_number)

    def get_adjoint_field_scaling(self, sim):
        omega = 2.0 * np.pi * sp.constants.speed_of_light / self.wavelengths
        adjoint_source_power = ModeMatch.get_source_power(sim, self.wavelengths)
        scaling_factor = np.conj(self.phase_prefactors) * omega * 1j / np.sqrt(adjoint_source_power)
        return scaling_factor.flatten()

    def get_wavelengths(self):
        return self.wavelengths